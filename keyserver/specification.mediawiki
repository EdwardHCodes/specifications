<pre>
  Title: Keyserver Protocol
  Author: Shammah Chancellor <shammah.chancellor@cashweb.io>
          Harry Barber <harry.barber@cashweb.io>
  Status: Draft
  Created: 2019-11-15
  License: MIT
</pre>

== Introduction ==

=== Abstract ===

The keyserver protocol allows public, cryptographically verifiable, replicated storage of Address:Metadata pairs. We describe a sufficient specification of the REST API and peer-to-peer protocol. 

=== Notational Conventions ===

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [[https://www.ietf.org/rfc/rfc2119.txt|RFC 2119]].

The rule URI-reference is included from [[https://tools.ietf.org/html/rfc3986|Uniform Resource Identifier (URI): Generic Syntax]].

Certain security-related terms are to be understood in the sense defined in [[https://tools.ietf.org/html/rfc4949|Internet Security Glossary, Version 2]].  These terms include, but are not limited to, "attack", "authentication", "authorization", "certificate", "sign", "signature", "trust", "validate", and "verify".

Unless otherwise noted, all the protocol parameter names and values are case sensitive.

=== Motivation ===

Traditional keyservers are subject to certificate spamming attacks. By being a first-class citizen in the cryptocurrency ecosystem, we are able to charge for key updates. This prevents an explosion of advertised certificates, and provides some funding for node operators. Other systems like OpenAlias, require that you trust the service provider is providing the correct addresses, while this keyserver cannot forge such updates as they are tied to a keyid which has been provided via another channel. At most, a malicious keyserver can censor a particular key, in which case other keyservers will provide it.

== Specification ==

We specify a REST API and peer-to-peer protocol sufficient to implement the keyservers replicated key/value store. The keys are Bitcoin Cash addresses and the values are signed and timestamped metadata.

We use the [[https://github.com/cashweb/specifications/blob/master/proof-of-payment-token/specification.mediawiki|Proof-of-Payment Authorization Framework]] to avoid spam by requiring the client pays to commit to metadata onchain. The commitment also acts as an anchor to allow reconciliation among keyservers.

The keyserver MUST provide the following endpoints:

{| class="wikitable"
! style="font-weight:bold;" | Path
! style="font-weight:bold;" | Method
! style="font-weight:bold;" | Purpose
! style="font-weight:bold;" | Protection
|-
| /keys/{addr}
| GET
| Get metadata from store
| None
|-
| /keys/{addr}
| PUT
| Put metadata to store
| Requires POP token
|}

=== Metadata ===

The central data type in the keyserver is the <code>AddressMetadata</code> message which is specified in the following [https://developers.google.com/protocol-buffers/docs/proto3|proto3] schema.

<pre>
syntax = "proto3";
package address_metadata;

// Basic key/value used to store header data.
message Header {
    string name = 1;
    string value = 2;
}

// Entry is an individual piece of structured data provided by wallet authors.
message Entry {
    // Kind is a hint to wallets as to what type of data to deserialize from the metadata field.
    string kind = 1;
    // The headers is excess metadata that may be useful to a wallet.
    repeated Header headers = 2;
    // Body of the metadata field.
    bytes entry_data = 3;
}

// Payload is the user-specified data section of a AddressMetadata that is covered by the users signature.
message Payload {
    // Timestamp allows servers to determine which version of the data is the most recent.
    int64 timestamp = 1;
    // TTL tells us how long this entry should exist before being considered invalid.
    int64 ttl = 2;
    // User specified data.  Presumably some conventional data determined by wallet authors.
    repeated Entry entries = 3;
}

// AddressMetadata is the basic unit of the keyserver.  It is used in both PUT and GET requests.
message AddressMetadata  {
    // Serialized version of the XPubKey.  The *hash* of this XPub should correspond to the `key` in the kv store.
    bytes pub_key = 1;
    // Signature is the signature of the metadata by XPubKey.
    bytes signature = 2;
    // Signature scheme provided.  Default is Schnorr, but can be ecdsa.
    enum SignatureScheme {
        SCHNORR = 0;
        ECDSA = 1;
    }
    SignatureScheme scheme = 3;
    // Payload is the metadata set by the user, and covered by the signature.
    bytes serialized_payload = 4;
}
</pre>

=== Bitcoin Network ===

Bitcoin has three standard networks: mainnet, testnet and regtest. The keyserver MUST operate in correspondence with one of these three. For example, if a keyserver is running in mainnet mode it MUST reject testnet and regtest net addresses as invalid and be connected to a mainnet Bitcoin node.

Segregating operation like this reduces confusion and provides testbeds.

=== Getting Metadata ===

When the keyserver receives a GET request to <code>/keys/{addr}</code> the following steps are performed.

# Validate and decode the Bitcoin address <code>addr</code>. If the address is a valid pay-to-pubkey-hash address it MUST be decoded returning the underlying public key hash.
#* Both base58 and cashaddr address formats MUST be supported.
#* Invalid addresses should be responded to with status code <code>400</code> and SHOULD yield an appropriate error message.
# The keyserver MUST lookup the public key hash from its internal database then respond with status code <code>200</code> and the serialized <code>AddressMetadata</code> in the message body.
#* If the metadata is not found the keyserver MUST respond with status code <code>404</code>.
#* On an internal database failure the keyserver MUST respond with status code <code>500</code>.

=== Putting Metadata ===

When the keyserver receives a PUT request to <code>/keys/{addr}</code> the following steps are performed.

=== Proof-of-Payment Authorization ===

Before putting metadata to the keyserver the client MUST obtain a POP token.

The keyserver MUST follow the Proof-of-Payment Authorization framework where:

* A PUT to <pre>/keys/{addr}</pre> with body containing the metadata digest.


== Footnotes ==

<references />

== References ==
