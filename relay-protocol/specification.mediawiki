<pre>
  Title: Relay Protocol
  Author: Shammah Chancellor <shammah.chancellor@cashweb.io>
          Harry Barber <harry.barber@cashweb.io>
  Status: Draft
  Created: 2019-11-15
  License: MIT
</pre>

== Introduction ==

=== Abstract ===

TODO

=== Notational Conventions ===

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [[https://www.ietf.org/rfc/rfc2119.txt|RFC 2119]].

The rule URI-reference is included from [[https://tools.ietf.org/html/rfc3986|Uniform Resource Identifier (URI): Generic Syntax]].

Certain security-related terms are to be understood in the sense defined in [[https://tools.ietf.org/html/rfc4949|Internet Security Glossary, Version 2]].  These terms include, but are not limited to, "attack", "authentication", "authorization", "certificate", "sign", "signature", "trust", "validate", and "verify".

Unless otherwise noted, all the protocol parameter names and values are case sensitive.

=== Motivation ===

TODO

== Overview ==

=== Address Payload ===

Throughout this specification, the use of "address payload" refers specifically to the decoded payload of an address. For example, <code>RIPEMD-160(SHA-256(public key))</code> for current Bitcoin addresses where the <code>public key</code> is a compressed public key.

=== Relay Messages ===

The messages specific to the relay protocol are defined in the following [[https://developers.google.com/protocol-buffers/docs/proto3|proto3]] schema.

<pre>
syntax = "proto3";
package relay;

// Basic key/value pair used to store header data.
message Header {
  string name = 1;
  string value = 2;
}

// Entry is an individual piece of structured data provided by wallet authors.
message ProfileEntry {
  // Kind is a hint to wallets as to what type of data to deserialize from the
  // metadata field.
  string kind = 1;
  // The headers is excess metadata that may be useful to a wallet.
  repeated Header headers = 2;
  // Body of the metadata field.
  bytes entry_data = 3;
}

// A profile attached to an address.
message Profile {
  // Timestamp allows servers to determine which version of the data is the most
  // recent. Given in milliseconds.
  int64 timestamp = 1;
  // TTL tells us how long this profile should exist before being considered
  // invalid. Given in milliseconds.
  int64 ttl = 2;
  // User specified data.  Presumably some conventional data determined by
  // wallet authors.
  repeated ProfileEntry entries = 3;
}

// Entry is an individual piece of structured data.
message Entry {
  // Informs the wallet what to do with this payload.
  string kind = 1;
  // The headers provide some extra metadata about the field that
  // may be relevant to the wallet.  At this time there are no meaningful
  // headers.
  repeated Header headers = 2;
  // Body of the metadata field.
  bytes entry_data = 3;
}

// Payload is the user-specified data section of the message that is
// encrypted by the shared secret.
message Payload {
  // Timestamp provided by sender.
  int64 timestamp = 1;
  // The entries, containing body of the payload.
  repeated Entry entries = 2;
}

// A stamp transaction paired with a list of vouts identifying to stamp outputs.
message StampOutpoints {
  // A serialized stamp transaction.
  bytes stamp_tx = 1;
  // The specified outputs of the stamp transaction.
  repeated uint32 vouts = 2;
}

// Represents a stamp. This is attached to Message in order to attach value.
message Stamp {
  // Represents the stamp type.
  enum StampType {
    None = 0;
    // Hash commitment means the stamp is being sent to the address specified by
    // public keys of the xpub defined by:
    // PublicKey: dG + SHA256(ciphertext)G
    // ChainCode: SHA256(ciphertext)
    MessageCommitment = 1;
  }
  // The stamp type.
  StampType stamp_type = 1;
  // A collection of stamp outpoints.
  repeated StampOutpoints stamp_outpoints = 2;
}

// The primary message used in communication over the cashweb protocol.
message Message {
  // The senders serialized public key.
  bytes source_public_key = 1;
  // The destinations serialized public key.
  bytes destination_public_key = 2;
  // Maleable server time. This field is optional.
  int64 received_time = 3;
  // The SHA-256 digest of the payload. This is independent of the MAC
  // as only the sender/receiver can verify MAC.
  //
  // The relay server may set this field if it strips the ciphertext from the
  // message it sends to the client over websockets. In which case the
  // ciphertext would be available over the payloads API.
  bytes payload_digest = 4;
  // The stamp attached to the message.
  Stamp stamp = 5;
  // Represents an encryption scheme.
  enum EncryptionScheme {
    // Indicates the message is plaintext.
    None = 0;
    // For EphemeralDH, ECDH is used to generate a shared secret based on the
    // combination of the source and destination pubkeys. The shared secret is
    // the ECDH combination of the source and destination keys, 
    // S = HMAC(sdG, salt)

    // The payload is encrypted with AES128 CBC with key given by the first 16
    // bytes of S and the IV given by the last 16 bytes of S.
    EphemeralDH = 1;
  }
  // The encryption scheme used on the payload.
  EncryptionScheme scheme = 6;
  // This salt is added to the HMAC to provide a shared source of entropy
  // (e.g. the Chaincode for stamp outputs: SHA256(chaincode))
  // but also to provide the sender a way to add a commitment to any additional
  // data they may want to prove they had later.
  //
  // One such example would be a commitment to their private key, so that
  // they can prove they sent the message. This may be important since some
  // wallets may want to increment internal state with each message they send --
  // and this provides a way to do so that is strong against forgery.
  bytes salt = 7;
  // The HMAC of the payload using the shared key, HMAC(ciphertext_digest, HMAC(sdG, salt)))
  bytes payload_hmac = 8;
  // Optional size, which may be set by the relay server. This enables the
  // client to deside if they want to download the payload based on the stamp
  // value.
  uint64 payload_size = 9;
  // The serialized and encrypted payload covered by the HMAC.
  //
  // This field may be stripped by a relay server if it is large. In which
  // case it will be made available at the payloads endpoint via the digest.
  // If the ciphertext is not set, the payload digest becomes a mandatory field.
  bytes payload = 100;
}

// Collection of messages. Pushed from client to server via HTTP.
message MessageSet { repeated Message messages = 1; }

// An error associated with the validation and insertion of a message.
message PushError {
  // Status code of the error.
  uint32 status_code = 1;
  // Textual information of the error.
  string error_text = 2;
}

// A collection of errors yeilded when pushing message to the server.
message PushErrors {
  // A map of errors, keyed by the index of the failed message.
  map<int32, PushError> errors = 1;
}

// A page of messages. Pulled from server via HTTP.
message MessagePage {
  // Collection of messages.
  repeated Message messages = 1;
  // The received time of the earliest message in the page.
  int64 start_time = 2;
  // The received time of the latest message in the page.
  int64 end_time = 3;
  // The payload digest of the earliest message in the page.
  bytes start_digest = 4;
  // The payload digest of the latest message in the page.
  bytes end_digest = 5;
}

// A page of payloads. Pulled from server via HTTP.
message PayloadPage {
  // Collection of payloads.
  repeated bytes payloads = 1;
  // The received time of the earliest payload in the page.
  int64 start_time = 2;
  // The received time of the latest payload in the page.
  int64 end_time = 3;
  // The payload digest of the earliest payload in the page.
  bytes start_digest = 4;
  // The payload digest of the latest payload in the page.
  bytes end_digest = 5;
}
</pre>

=== Authorization Wrapper ===

The <code>AuthWrapper</code> is a proto3 message allowing payloads to be covered by a ECDSA or Schnorr signature. Within the relay server protocol the <code>Profile</code> plays the role of the payload - having the metadata GET and PUT while wrapped provides integrity, authentication, and non-repuditation.

<pre>
syntax = "proto3";
package wrapper;

message AuthWrapper {
    // Serialized version of the public key.
    bytes public_key = 1;
    // Signature is the signature of the metadata by public key.
    bytes signature = 2;
    // Signature scheme provided.  Default is Schnorr, but can be ecdsa.
    enum SignatureScheme {
        SCHNORR = 0;
        ECDSA = 1;
    }
    SignatureScheme scheme = 3;
    // The serialized payload covered by the signature.
    bytes serialized_payload = 4;
    // The SHA256 digest of the serialized_payload.
    bytes payload_digest = 5;
}
</pre>

The standalone specification for the <code>AuthWrapper</code> can be [[https://github.com/cashweb/specifications/blob/master/authorization-wrapper/specification.mediawiki|found here]].

== Authenticated Encryption ==

Messages simulatenously enjoy confidentiality and authenticity via the use of authentication encryption.

For this section we abbreviate the 256-bit private key of the public key <code>dG = destination_public_key</code> as <code>d</code> and, similarly for <code>s</code> for the <code>sG = source_public_key</code>.

We make heavy use of the [[https://tools.ietf.org/html/rfc4634|HMAC algorithm]], we use <code>HMAC(key, message)</code> to denote the HMAC-SHA-256 function.

=== Encryption ===

If the <code>scheme</code> is <code>None</code> then the ciphertext MUST be unencrypted.



If the <code>scheme</code> is <code>EphemeralDH</code> then the encryption key MUST be constructed as follows:

<pre>
key = HMAC(ser(sdG), salt)
</pre>

where <code>ser(sdG)</code> is the 20 byte serialized shared secret and the <code>salt</code> is provided from the <code>Message</code> field.

The <code>ciphertext</code> is then constructed using the [[https://tools.ietf.org/html/rfc3602|AES-CBC-256]] with key given above and a null IV. Decryption can be performed by anyone with access to <code>sdG</code> and the <code>salt</code>.

One MUST NOT reuse the salt between messages sent to the same destination as this breaks the security of the cryptography.

=== Authenticate ===

The <code>ciphertext_hmac</code> MUST be constructed as follows:

<pre>
ciphertext_digest = HMAC(HMAC(ser(sdG), salt), ciphertext_digest)
</pre>

where <code>ser(sdG)</code> is the 20 byte serialized shared secret and the <code>salt</code> is provided from the <code>Message</code> field.

Authentication of a <code>Message</code> may be performed by anyone with access to <code>sdG</code>, <code>salt</code>, and <code>ciphertext_digest</code> by comparison of the <code>ciphertext_hmac</code> given in the message with the construction.

== Stamps ==

A "stamp" is a collection of Bitcoin transactions with distinguished outpoints, which is cryptographically attached to messages. This information is contained within the <code>Stamp</code> message.

If the <code>stamp_type</code> is <code>None</code> then the <code>stamp_outpoints</code> field MUST be empty.

If the <code>stamp_type</code> is <code>MessageCommitment</code> then each outpoint, indexed by <code>index</code>, in <code>stamp_outpoints</code> is subject to the following constraints:

* The <code>stamp_tx</code> MUST decode to a valid Bitcoin transaction.
* Each ouput of <code>stamp_tx</code> indexed by a <code>vout</code> in the <code>vouts</code> field MUST be a "pay-to-pubkey-hash" generated using [[https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki|Hierarchical Deterministic Wallets]] using the path <code>44/145/index/vout</code>.

== REST API Specification ==

The relay server provides a REST API to allow clients to get and put messages and profiles.

We use the [[https://github.com/cashweb/specifications/blob/master/proof-of-payment-token/specification.mediawiki|Proof-of-Payment Authorization Framework]] to allow new accounts.

The relay server MUST provide the following endpoints:

{| class="wikitable"
! style="font-weight:bold;" | Path
! style="font-weight:bold;" | Method
! style="font-weight:bold;" | Purpose
! style="font-weight:bold;" | Protection
|-
| /messages/{address}
| GET
| Get messages from an address
| Requires POP token
|-
| /messages/{address}
| PUT
| Put messages to an address
| None
|-
| /messages/{address}
| GET
| Get messages from an address
| None
|-
| /profiles/{address}
| GET
| Get profile to an address
| Requires POP token
|-
| /profiles/{address}
| PUT
| Put profile to an address
| Requires POP token
|-
| /ws/{address}
| GET
| Connect to a websocket stream of messages
| Requires POP token
|-
|}

=== Proof-of-Payment Authorization ===

Before getting messages or putting a profile to a target address on the relay server the client MUST first obtain a POP token. The client MAY achieve this via the POP token framework.

To initiate the payment process the client SHOULD first send an empty GET or PUT request to the <code>/messages/{address}</code> or <code>/profiles/{address}</code> respectively. This initial request acts as the "authorization request" in the POP token protocol.

=== Getting Profiles ===

To get a profile, the client MUST send a GET request to <code>/profiles/{address}</code> with an empty body.

The relay server MUST then perform the following steps:

# Validate and decode the <code>address</code> given in the URL, returning the address payload.
#* Both base58 and cashaddr address formats MUST be supported.
#* Invalid addresses MUST be responded to with status code <code>400</code> and SHOULD include an appropriate error message in the body.
# Lookup the address payload <code>AuthWrapper</code> containing the <code>Profile</code>, then respond with status code <code>200</code> and the serialized <code>AuthWrapper</code>.
#* If the metadata is not found then the relay server MUST respond with status code <code>404</code>.
#* If the summation of the <code>timestamp</code> and <code>ttl</code> fields of the <code>Payload</code> is greater than the current unix time in milliseconds then the relay server MUST respond with status code <code>404</code>.
#* On an internal failure the relay server MUST respond with status code <code>500</code>.

Note that this means requests using different encodings of the same underlying address payload MUST retrieve the same metadata.

=== Putting Profiles ===

To upload a profile the client MUST send a PUT request to <code>/profiles/{target address}</code> with a <code>Authorization</code> header containing the POP token and the serialized <code>AuthWrapper</code>, containing the <code>Profile</code>, as the body.

The relay server MUST then perform the following steps:

# Validate and decode the <code>target address</code> given in the URL, returning the address payload. 
#* Both base58 and cashaddr address formats MUST be supported.
#* Invalid addresses MUST be responded to with status code <code>400</code> and SHOULD include an appropriate error message in the body.
# Check that the request body is non-empty and successfully deserializes into a <code>AuthWrapper</code> message and its <code>serialized_payload</code> field successfully deserializes into a <code>Profile</code> message. If either are malformed then the relay server MUST respond with status code <code>400</code> and SHOULD include an appropriate error message in the body.
# Use the <code>public_key</code> field of the <code>AuthWrapper</code> to generate an address and check whether its payload matches the target address's payload. In the case of Bitcoin, this condition is that the address decodes into the public key hash.
# Check that the summation of the <code>timestamp</code> and <code>ttl</code> fields of the <code>Profile</code> is greater than the current unix time, else the relay server MUST respond with status code <code>400</code> and SHOULD include an appropriate error message in the body.
#* If the POP token fails validation the relay server MUST respond with status code <code>400</code> and SHOULD include an appropriate error message in the body.
#* If the POP token is missing from the <code>Authorization</code> header the relay server MUST respond with status code <code>402</code> and SHOULD include an appropriate error message in the body.
# Verify that the <code>AuthWrapper</code> passes the validation described in the [[https://github.com/cashweb/specifications/blob/master/authorization-wrapper/specification.mediawiki||Authorization Wrapper Framework]], if not then the keyserver MUST respond with status code <code>400</code> and SHOULD include an appropriate error message in the body.
# If the an existing <code>Profile</code> message exists at the address payload then check whether the timestamp given in the <code>Payload</code> of the new <code>TODO</code> is strictly larger than the existing timestamp. If not, then the relay server MUST respond with status code <code>400</code> and SHOULD include an appropriate error message in the body.
# The relay server MUST store the new <code>AuthWrapper</code> at key given by the address payload. 
# Return status code <code>200</code>.

=== Getting Messages ===

To get a single or range of messages, the client MUST send a GET request to <code>/messages/{address}</code> with a <code>Authorization</code> header containing the POP token, the query string parameters described below, and the serialized <code>MessagePage</code> in the body. The <code>messages</code> field of the <code>MessagePage</code> is collected in correspondence with the conditions below and ordered by the <code>received_time</code> field. The start and end fields of the <code>MessagePage</code> are filled from the data from the first and last messages.

==== Single Digest ====

If the <code>digest</code> query string parameter is present the relay server MUST collect the single message in the addresses inbox with <code>payload_digest</code> matching <code>digest</code>. It MUST NOT be used in combination with any other parameters, otherwise the relay server MUST respond with status code <code>400</code> and SHOULD include an appriopriate error message.

==== Range Queries ====

If the <code>start_time</code> query string parameter is present the relay server MUST collect messages in the address inbox with <code>received_time</code> greater than or equal to <code>start_time</code>. It MUST NOT be used in combination <code>start_digest</code>, otherwise the relay server MUST respond with status code <code>400</code> and SHOULD include an appriopriate error message.

If the <code>start_digest</code> query string parameter is present the relay server MUST collect messages in the address inbox with <code>received_time</code> greater than or equal to the <code>received_time</code> given in the message whose payload matches <code>payload_digest</code>. It MUST NOT be used in combination <code>start_time</code>, otherwise the relay server MUST respond with status code <code>400</code> and SHOULD include an appriopriate error message. If <code>start_digest</code> matches no payload at the specified address the relay server MUST respond with <code>404</code> and SHOULD include an appriopriate error message.

If start parameters are absent then the relay server MUST assume that <code>start_time</code> is 0.

If the <code>end_time</code> query string parameter is present the relay server MUST collect messages in the address inbox with <code>received_time</code> less than <code>end_time</code>. It MUST NOT be used in combination <code>end_digest</code>, otherwise the relay server MUST respond with status code <code>400</code> and SHOULD include an appriopriate error message.

If the <code>end_digest</code> query string parameter is present the relay server MUST collect messages in the address inbox with <code>received_time</code> less than the <code>received_time</code> given in the message whose payload matches <code>payload_digest</code>. It MUST NOT be used in combination <code>end_time</code>, otherwise the relay server MUST respond with status code <code>400</code> and SHOULD include an appriopriate error message. If <code>end_digest</code> matches no payload at the specified address the relay server MUST respond with <code>404</code> and SHOULD include an appriopriate error message.

If start parameters are absent then the relay server MUST assume that <code>end_time</code> is infinity.

=== Getting Payloads ===

The <code>/payloads</code> resource functions identically to the <code>/messages</code> endpoint described above, with the exception that the relay server returns a serialized <code>PayloadPage</code> containing the serialized <code>Payload</code> instead. 

=== Putting Messages ===

To send messages to a addresses inbox, the client MUST send a PUT request to <code>/messages/{inbox address}</code> with a <code>Authorization</code> header containing the POP token and the serialized <code>AuthWrapper</code>, containing the <code>TODO</code>, as the body.

=== Subscribing to Messages ===

To connect to a stream of websockets, the client MUST send a GET request to <code>/ws/{address}</code> with a <code>Authorization</code> header containing the POP token and an empty body.

The relay server MUST send a serialized <code>Message</code> to the client each time a new message arrives in the addresses inbox.

== Footnotes ==

<references />

== References ==
* [[https://developers.google.com/protocol-buffers/docs/proto3|Language Guide (proto3)]]
* [[https://github.com/cashweb/specifications/blob/master/proof-of-payment-token/specification.mediawiki|Proof-of-Payment Authorization Framework]]
* [[https://tools.ietf.org/html/rfc3602|RFC 3602 - The AES-CBC Cipher Algorithm and Its Use with IPsec]]
* [[https://tools.ietf.org/html/rfc4634|RFC 4634 - US Secure Hash Algorithms (SHA and HMAC-SHA)]]
* [[https://tools.ietf.org/html/rfc5869|RFC 5869 - HMAC-based Extract-and-Expand Key Derivation Function (HKDF)]]
* [[https://tools.ietf.org/html/rfc6090|RFC 6090 - Fundamental Elliptic Curve Cryptography Algorithms]]
* [[https://tools.ietf.org/html/rfc6455|RFC 6455 - The WebSocket Protocol]]
