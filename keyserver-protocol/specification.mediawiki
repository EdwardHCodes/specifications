<pre>
  Title: Keyserver Protocol
  Author: Shammah Chancellor <shammah.chancellor@cashweb.io>
          Harry Barber <harry.barber@cashweb.io>
  Status: Draft
  Created: 2019-11-15
  License: MIT
</pre>

== Introduction ==

=== Abstract ===

The keyserver protocol allows public, cryptographically verifiable, replicated storage of Address:Metadata pairs. We describe a sufficient specification of the REST API and peer-to-peer protocol. 

=== Notational Conventions ===

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [[https://www.ietf.org/rfc/rfc2119.txt|RFC 2119]].

The rule URI-reference is included from [[https://tools.ietf.org/html/rfc3986|Uniform Resource Identifier (URI): Generic Syntax]].

Certain security-related terms are to be understood in the sense defined in [[https://tools.ietf.org/html/rfc4949|Internet Security Glossary, Version 2]].  These terms include, but are not limited to, "attack", "authentication", "authorization", "certificate", "sign", "signature", "trust", "validate", and "verify".

Unless otherwise noted, all the protocol parameter names and values are case sensitive.

=== Motivation ===

Traditional keyservers are subject to certificate spamming attacks. By being a first-class citizen in the cryptocurrency ecosystem, we are able to charge for key updates. This prevents an explosion of advertised certificates, and provides some funding for node operators. Other systems like OpenAlias, require that you trust the service provider is providing the correct addresses, while this keyserver cannot forge such updates as they are tied to a keyid which has been provided via another channel. At most, a malicious keyserver can censor a particular key, in which case other keyservers will provide it.

== REST API Specification ==

We use the [[https://github.com/cashweb/specifications/blob/master/proof-of-payment-token/specification.mediawiki|Proof-of-Payment Authorization Framework]] to avoid spam by requiring the client pays to commit to metadata onchain. The commitment also acts as an anchor to allow reconciliation among keyservers.

The keyserver MUST provide the following endpoints:

{| class="wikitable"
! style="font-weight:bold;" | Path
! style="font-weight:bold;" | Method
! style="font-weight:bold;" | Purpose
! style="font-weight:bold;" | Protection
|-
| /keys/{addr}
| GET
| Get metadata from store
| None
|-
| /keys/{addr}
| PUT
| Put metadata to store
| Requires POP token
|-
| /commit
| POST
| Initiate the purchase of a POP token
| None
|}

=== Metadata ===

The central data type in the keyserver is the <code>AddressMetadata</code> message which is specified in the following [[https://developers.google.com/protocol-buffers/docs/proto3|proto3]] schema.

<pre>
syntax = "proto3";
package address_metadata;

// Basic key/value used to store header data.
message Header {
    string name = 1;
    string value = 2;
}

// Entry is an individual piece of structured data provided by wallet authors.
message Entry {
    // Kind is a hint to wallets as to what type of data to deserialize from the metadata field.
    string kind = 1;
    // The headers is excess metadata that may be useful to a wallet.
    repeated Header headers = 2;
    // Body of the metadata field.
    bytes entry_data = 3;
}

// Payload is the user-specified data section of a AddressMetadata that is covered by the users signature.
message Payload {
    // Timestamp allows servers to determine which version of the data is the most recent.
    int64 timestamp = 1;
    // TTL tells us how long this entry should exist before being considered invalid.
    int64 ttl = 2;
    // User specified data.  Presumably some conventional data determined by wallet authors.
    repeated Entry entries = 3;
}

// AddressMetadata is the basic unit of the keyserver.  It is used in both PUT and GET requests.
message AddressMetadata  {
    // Serialized version of the XPubKey.  The *hash* of this XPub should correspond to the `key` in the kv store.
    bytes pub_key = 1;
    // Signature is the signature of the metadata by XPubKey.
    bytes signature = 2;
    // Signature scheme provided.  Default is Schnorr, but can be ecdsa.
    enum SignatureScheme {
        SCHNORR = 0;
        ECDSA = 1;
    }
    SignatureScheme scheme = 3;
    // Payload is the metadata set by the user, and covered by the signature.
    bytes serialized_payload = 4;
}
</pre>

=== Bitcoin Network ===

Bitcoin has three standard networks: mainnet, testnet and regtest. The keyserver MUST operate in correspondence with one of these three. For example, if a keyserver is running in mainnet mode it MUST reject testnet and regtest net addresses as invalid and be connected to a mainnet Bitcoin node.

Segregating operation like this reduces confusion and provides testbeds.

=== Getting Metadata ===

When the keyserver receives a GET request to <code>/keys/{addr}</code> the following steps MUST be performed:

# Validate and decode the Bitcoin address <code>addr</code>. If the address is a valid pay-to-pubkey-hash address then decode it returning the underlying public key hash.
#* Both base58 and cashaddr address formats MUST be supported.
#* Invalid addresses MUST be responded to with status code <code>400</code> and SHOULD include an appropriate error message in the body.
# Lookup the public key hash using an internal database then respond with status code <code>200</code> and the serialized <code>AddressMetadata</code> in the message body.
#* If the metadata is not found the keyserver MUST respond with status code <code>404</code>.
#* On an internal database failure the keyserver MUST respond with status code <code>500</code>.

=== Proof-of-Payment Authorization ===

Before putting metadata to the keyserver the client MUST obtain a POP token.

To initiate the payment process the client SHOULD first send a PUT request to <pre>/commit</pre> with body containing a "commitment digest". This the public key hash of the desired PUT address concatenated with the [[https://tools.ietf.org/html/rfc4634|SHA-256]] digest of the serialized <code>AddressMetadata</code>. 

This initial commitment acts as the authorization request in the Proof-of-Payment Authorization framework.

On receiving such a request the kesyerver MUST first perform the following steps:

# Validate the public key hash, if invalid the keyserver MUST respond with status code <code>400</code> and SHOULD include an appropriate error message in the body.
# Check whether digest given is not 32 bytes long, if not the keyserver MUST respond with status <code>400</code> and SHOULD include an appropriate error message in the body.

This commitment digest will be committed to chain and signals to other keyservers that this address:metadata pair has provided the tokenized proof-of-work required to be replicated.

Note here that this is a commitment to a specific encoding of the <code>AddressMetadata</code> and that protocol buffers has a non-deterministic encoding. Specical care MUST be taken in regards to this - a keyserver MUST NOT deserialize then serialize a <code>AddressMetadata</code> under the assumption that it still subject to the commitment.

The keyserver MUST continue to follow the POP protocol with following the additional requirements:

* It is RECOMMENDED that the commitment digest is included in the <code>merchant_data</code> field of the <code>PaymentDetails</code> message to allow for a stateless protocol.
* It is RECOMMENDED that the <code>outputs</code> field of the <code>PaymentRequest</code> message is a one element list consisting of an OP_RETURN output containing the message digest. It is REQUIRED that this onchain commitment is made, however altruistic keyservers MAY choose to broadcast such a transaction themselves.

=== Putting Metadata ===

When the keyserver receives a PUT request to <code>/keys/{addr}</code> the following steps are performed.

# Validate and decode the Bitcoin address <code>addr</code>. If the address is a valid pay-to-pubkey-hash address then decode it returning the underlying public key hash.
#* Both base58 and cashaddr address formats MUST be supported.
#* Invalid addresses MUST be responded to with status code <code>400</code> and SHOULD yield an appropriate error message.

== Peer-to-Peer Specification ==

== Footnotes ==

<references />

== References ==
