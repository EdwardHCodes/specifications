<pre>
  Title: Keyserver Protocol
  Author: Shammah Chancellor <shammah.chancellor@cashweb.io>
          Harry Barber <harry.barber@cashweb.io>
  Status: Draft
  Created: 2019-11-15
  License: MIT
</pre>

== Introduction ==

=== Abstract ===

The keyserver protocol allows public, cryptographically verifiable, replicated storage of Address:Metadata pairs. We describe a sufficient specification of the REST API and peer-to-peer protocol. 

=== Notational Conventions ===

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [[https://www.ietf.org/rfc/rfc2119.txt|RFC 2119]].

The rule URI-reference is included from [[https://tools.ietf.org/html/rfc3986|Uniform Resource Identifier (URI): Generic Syntax]].

Certain security-related terms are to be understood in the sense defined in [[https://tools.ietf.org/html/rfc4949|Internet Security Glossary, Version 2]].  These terms include, but are not limited to, "attack", "authentication", "authorization", "certificate", "sign", "signature", "trust", "validate", and "verify".

Unless otherwise noted, all the protocol parameter names and values are case sensitive.

=== Motivation ===

Traditional keyservers are subject to certificate spamming attacks. By being a first-class citizen in the cryptocurrency ecosystem, we are able to charge for key updates. This prevents an explosion of advertised certificates, and provides some funding for node operators. Other systems like OpenAlias, require that you trust the service provider is providing the correct addresses, while this keyserver cannot forge such updates as they are tied to a keyid which has been provided via another channel. At most, a malicious keyserver can censor a particular key, in which case other keyservers will provide it.

== Overview ==

=== Metadata ===

The central data type in the keyserver is the <code>AddressMetadata</code> message which is specified in the following [[https://developers.google.com/protocol-buffers/docs/proto3|proto3]] schema.

<pre>
syntax = "proto3";
package address_metadata;

// Basic key/value used to store header data.
message Header {
    string name = 1;
    string value = 2;
}

// Entry is an individual piece of structured data provided by wallet authors.
message Entry {
    // Kind is a hint to wallets as to what type of data to deserialize from the metadata field.
    string kind = 1;
    // The headers is excess metadata that may be useful to a wallet.
    repeated Header headers = 2;
    // Body of the metadata field.
    bytes entry_data = 3;
}

// Payload is the user-specified data section of a AddressMetadata that is covered by the users signature.
message Payload {
    // Timestamp allows servers to determine which version of the data is the most recent.
    int64 timestamp = 1;
    // TTL tells us how long this entry should exist before being considered invalid.
    int64 ttl = 2;
    // User specified data.  Presumably some conventional data determined by wallet authors.
    repeated Entry entries = 3;
}

// AddressMetadata is the basic unit of the keyserver.  It is used in both PUT and GET requests.
message AddressMetadata  {
    // Serialized version of the XPubKey.  The *hash* of this XPub should correspond to the `key` in the kv store.
    bytes pub_key = 1;
    // Signature is the signature of the metadata by XPubKey.
    bytes signature = 2;
    // Signature scheme provided.  Default is Schnorr, but can be ecdsa.
    enum SignatureScheme {
        SCHNORR = 0;
        ECDSA = 1;
    }
    SignatureScheme scheme = 3;
    // Payload is the metadata set by the user, and covered by the signature.
    bytes serialized_payload = 4;
}
</pre>

=== Bitcoin Network ===

Bitcoin has three standard networks: mainnet, testnet and regtest. The keyserver MUST operate in correspondence with one of these three. For example, if a keyserver is running in mainnet mode it MUST reject testnet and regtest net addresses as invalid and be connected to a mainnet Bitcoin node.

Segregating operation like this reduces confusion and provides testbeds.

== REST API Specification ==

The keyserver provides a REST API to allow clients and other keyservers to get and put metadata.

We use the [[https://github.com/cashweb/specifications/blob/master/proof-of-payment-token/specification.mediawiki|Proof-of-Payment Authorization Framework]] to avoid spam by requiring the client pays to commit to metadata onchain. The commitment also acts as an anchor to allow reconciliation among keyservers.

The keyserver MUST provide the following endpoints:

{| class="wikitable"
! style="font-weight:bold;" | Path
! style="font-weight:bold;" | Method
! style="font-weight:bold;" | Purpose
! style="font-weight:bold;" | Protection
|-
| /keys/{addr}
| GET
| Get metadata from store
| None
|-
| /keys/{addr}
| PUT
| Put metadata to store
| Requires POP token
|-
| /commit
| POST
| Initiate the purchase of a POP token
| None
|}


=== Getting Metadata ===

To get metadata the client MUST send a GET request to <code>/keys/{addr}</code> with an empty body.

The keyserver MUST then perform the following steps:

# Validate and decode the Bitcoin address <code>addr</code>. If the address is a valid pay-to-pubkey-hash address then decode it returning the underlying public key hash.
#* Both base58 and cashaddr address formats MUST be supported.
#* Invalid addresses MUST be responded to with status code <code>400</code> and SHOULD include an appropriate error message in the body.
# Lookup the public key hash using an internal database then respond with status code <code>200</code> and the serialized <code>AddressMetadata</code> in the message body.
#* If the metadata is not found the keyserver MUST respond with status code <code>404</code>.
#* On an internal database failure the keyserver MUST respond with status code <code>500</code>.

=== Proof-of-Payment Authorization ===

Before putting metadata to the keyserver the client SHOULD obtain a POP token.

To initiate the payment process the client MUST first send a PUT request to <code>/commit</code> with body containing a "metadata commitment". This is the [[https://tools.ietf.org/html/rfc4634|SHA-256]] digest of the concatenation of the public key hash associated to the desired PUT address and the serialized <code>AddressMetadata</code>.

<pre>metadata commitment = SHA256(public key hash || address metadata)</pre>

This initial request acts as the authorization request in the POP token protocol.

On receiving such a request the kesyerver MUST check whether digest given is 32 bytes long, if not the keyserver MUST respond with status <code>400</code> and SHOULD include an appropriate error message in the body.

The metadata commitment will be committed to chain and signals to other keyservers that this <code>address:metadata</code> pair has provided the tokenized proof-of-work required to be replicated.

Note that this is a commitment to a '''''specific encoding''''' of the <code>AddressMetadata</code> and that protocol buffers has a non-deterministic encoding. Any implementation MUST take special care in regards to this.

The keyserver MUST continue to follow the POP protocol with following the additions:

* It is RECOMMENDED that the metadata commitment is included in the <code>merchant_data</code> field of the <code>PaymentDetails</code> message to allow for a stateless protocol.
* It is RECOMMENDED that the <code>outputs</code> field of the <code>PaymentRequest</code> message is a one element list consisting of an OP_RETURN output containing the message digest. It is REQUIRED that this onchain commitment is made, however altruistic keyservers MAY choose to broadcast such a transaction themselves.
* The POP token presented to the client MUST consist of the base64 encoding of the concatenation of the raw transaction ID and big endian serialization output index.

Divergence from the recommendations above SHOULD NOT disrupt the operation a client following the POP token protocol. Furthermore, providing that a transaction with the required OP_RETURN is broadcast to the Bitcoin network then the peer-to-peer protocol remains unaffected.

=== Putting Metadata ===

When the keyserver receives a PUT request to <code>/keys/{addr}</code> with the serialized <code>AddressMetadata</code>, the following steps are performed:

# Validate and decode the Bitcoin address <code>addr</code>. If the address is a valid pay-to-pubkey-hash address then decode it returning the underlying public key hash.
#* Both base58 and cashaddr address formats MUST be supported.
#* Invalid addresses MUST be responded to with status code <code>400</code> and SHOULD include an appropriate error message in the body.
# Check that the request body is non-empty and successfully deserializes into a <code>AddressMetadata</code> message and its <code>serialized_payload</code> field successfully deserializes into a <code>Payload</code> message. If either are malformed then the keyserver MUST respond with status code <code>400</code> and SHOULD include an appropriate error message in the body.
# The RECOMMENDED POP token validation method consists of extracting the transaction ID and output index, fetching the metadata digest, and then comparing it to digest of the reported public key hash and serialized <code>AddressMetadata</code>.
#* If the POP token fails validation then it is RECOMMENDED that the keyserver responds with status code <code>400</code> and SHOULD include an appropriate error message in the body.
#* If the POP token is missing from the <code>Authorization</code> header then it is RECOMMENDED that the keyserver responds with status code <code>402</code> and SHOULD include an appropriate error message in the body.
# Check that the the <code>signature</code> field contains a signature over the <code>serialized_payload</code> using a private key associated with the public key given in the <code>pub_key</code> field using the signature scheme given in the <code>scheme</code> field.
#* If the signature is found to be invalid or the <code>scheme</code> is not found then the keyserver MUST respond with status code <code>400</code> and SHOULD include an appropriate error message in the body.
# If the an existing <code>AddressMetadata</code> message exists at the public key hash of the internal database then check whether the timestamp given in the <code>Payload</code> of the new <code>AddressMetadata</code> is strictly larger than the existing timestamp. If not, then the keyserver MUST respond with status code <code>400</code> and SHOULD include an appropriate error message in the body.
# The keyserver MUST insert the new <code>AddressMetadata</code> into internal database at key given by the public key hash. 
# Return status code <code>200</code>.

== Peer-to-Peer Specification ==

Keyservers are required to communicate between each other to allow replication. 

== Footnotes ==

<references />

== References ==
